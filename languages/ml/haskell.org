- https://evanrelf.com/haskell-libraries-i-love
- Styleguide https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
- Mailing List https://mail.haskell.org/mailman/listinfo/haskell-cafe
- Course: MOOC Erik Meijer https://www.youtube.com/playlist?list=PLphMJRtThhgS_8Psjv5aw-0ex8cT8Y-Sk
- Article: Monads https://blog.plover.com/prog/burritos.html
- Article: https://paulspontifications.blogspot.com/2013/01/when-haskell-is-faster-than-c.html
- Videos: Haskell beginners 2022 https://www.youtube.com/watch?v=6MsQcUprO9o&list=PLOJjn67NeYg9cWA4hyIWcxfaeX64pwo1c
- https://www.schoolofhaskell.com/school/advanced-haskell/beautiful-concurrency/3-software-transactional-memory
- https://github.com/prathyvsh/category-theory-resources
- Functional Parsing - Computerphile https://www.youtube.com/watch?v=dDtZLm7HIJs
- https://work.njae.me.uk/2021/12/21/advent-of-code-2021-day-19/
- Category Theory for Programmers https://www.youtube.com/watch?v=SmXB2K_5lcA
- http://sordina.github.io/blog/2021/01/03/1609638326-advent19b.html
- Usage Examples of Haskell https://homepages.inf.ed.ac.uk/wadler/realworld/
- https://hackage.haskell.org/package/rio
  https://www.fpcomplete.com/haskell/library/rio/
- CIS194 https://www.cis.upenn.edu/~cis194/fall16/lectures/01-intro.html
  CS240 2016 http://www.scs.stanford.edu/16wi-cs240h/
  CS240 2014 http://www.scs.stanford.edu/14sp-cs240h/
  CS240 code https://github.com/Chouffe/cs240
- Streamers https://github.com/chiroptical/declarative-programming-streams
- Streamer https://www.youtube.com/c/cvladfp/videos
- Memory Usage https://stackoverflow.com/questions/459725/how-to-reduce-memory-usage-in-a-haskell-app
- FPGA Clash Talks https://unsafeperform.io/talks/
- Book: Retrocomputing with Clash: Haskell for FPGA Hardware Design
  https://unsafeperform.io/retroclash/
- https://github.com/reanimate/reanimate
- Haskell via Sokoban - Tutorial - https://haskell-via-sokoban.nomeata.de/
- Learn Haskell making a static blog generator - https://soupi.github.io/learn-haskell-blog-generator/
- https://crypto.stanford.edu/~blynn/haskell/
- https://leanpub.com/haskell-cookbook/read
- https://www.youtube.com/channel/UCNp-DVb8cQRIOo32sZhWgNg
- cabal v2-repl exe:CABALPKGNAME -- give a ghci shell with all deps loaded
- https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#g:5
- http://www.cis.syr.edu/~sueo/cis252/emacs.html
- https://hoogle.haskell.org/
- euterpea example http://donyaquick.com/interesting-music-in-four-lines-of-code/
- quickstart euterpea https://github.com/madjestic/nu/blob/02eb3957f9ba5d0f0fbac7cd260f7142227a7008/Projects/blogs/turtlesturtlesturtles/posts/2018-11-29-a-quick-start-with-Euterpea.md
- Euterpea Interactive-Haskell with Literate-Haskell https://github.com/lfborjas/distractions/blob/a6b6bcd09270fa73233b05f3afb1800b977da9c3/haskell_school_of_music/README.md
- https://github.com/graninas/software-design-in-haskell
- https://kowainik.github.io/posts/haskell-mini-patterns
- https://github.com/kowainik/learn4haskell
- https://en.wikipedia.org/wiki/Dependent_type
- https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
- https://github.com/omelkonian/AlgoRhythm (music)
- Making Algorithmic Music
  Compose NYC 2019
  Speaker: Donya Quick
  https://www.youtube.com/watch?v=9Fg54XAr044
- Haskell MOOC University of Helsinki
  https://haskell.mooc.fi/material/
  https://github.com/moocfi/haskell-mooc
- 2011
  Stanford CS240h, Functional Systems in Haskell
  https://github.com/bos/stanford-cs240h
  http://www.scs.stanford.edu/11au-cs240h/notes/
- https://github.com/hzlmn/haskell-must-watch
* Build
- -I0
  -Iw
  +RTS -I0 -RTS
  -rtsopts to ghc-options in .cabal
* Personalities
** Simon Peyton-Jones
- haskell comitee on design
** Philip Wadler
- haskell comitee on design
* Backend Web Programming in Haskell - Tsoding
https://www.twitch.tv/videos/743607386
https://github.com/tsoding/tsoken/blob/master/src/Main.hs
* Setup
  - https://github.com/haskell/haskell-ide-engine
  - https://github.com/soupi/minimal-haskell-emacs (setup)
  - https://github.com/ndmitchell/ghcid "flymake"
  - https://github.com/ndmitchell/hlint "flycheck"
  - https://github.com/chrisdone/hindent "gofmt"
* Libraries
- A fast, light-weight web server for WAI applications.
  https://hackage.haskell.org/package/warp
  https://hackage.haskell.org/package/wai
- REST - A family of combinators for defining webservices APIs and serving them
  https://hackage.haskell.org/package/servant
- https://hackage.haskell.org/package/turtle-1.5.21/docs/Turtle-Tutorial.html
- Conduit is a framework for dealing with streaming data, such as reading raw bytes from a file, parsing a CSV response body from an HTTP request, or performing an action on all files in a directory tree. 
  https://github.com/snoyberg/conduit
- It is defined as a monad transformer that can be stacked on arbitrary monads, and it is also parametric in the input stream type.
  https://hackage.haskell.org/package/parsec
- State of the Haskell ecosystem
  https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
* Learn
** Other
- https://github.com/bitemyapp/fp-course
- https://github.com/hmemcpy/milewski-ctfp-pdf
- CIS 194: Introduction to Haskell (Spring 2013)
  https://www.seas.upenn.edu/~cis194/spring13/lectures.html
- https://threadreaderapp.com/thread/1277615394560360449.html
- https://github.com/Kuratoro/haskell.zettel.page/blob/master/2012502.md
- Applied Haskell is a commercial training program focusing on teaching intermediate Haskell.
  https://www.fpcomplete.com/haskell/syllabus/
- http://learnyouahaskell.com/chapters
- https://www.reddit.com/r/haskell/comments/d5og5n/which_book/
- https://github.com/i-am-tom/haskell-exercises (extensions)
- https://github.com/caiorss/Functional-Programming
- What I Wish I Knew When Learning Haskell
  http://dev.stephendiehl.com/hask/
- https://kowainik.github.io/posts/haskell-mini-patterns
- https://github.com/soupi/haskell-study-plan
- https://github.com/alpacaaa/zero-bullshit-haskell
- https://github.com/tssm/up-to-date-real-world-haskell
- https://github.com/graninas/software-design-in-haskell
- https://github.com/bitemyapp/learnhaskell
** Monad Tutorials
- https://www.lambdacat.com/the-midnight-monad-a-journey-to-enlightenment/
- https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
- https://en.wikibooks.org/wiki/Haskell/Understanding_monads
- http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
- https://web.archive.org/web/20081206204420/http://www.loria.fr/~kow/monads/index.html
- https://blog.plover.com/prog/burritos.html
  https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
  https://chrisdone.com/posts/monads-are-burritos/
* Videos
** Tsoding
- Haskell AMA https://www.twitch.tv/videos/736842835
- Haskell > JavaScript https://www.twitch.tv/videos/750508584
- Functional Programming in Production https://www.twitch.tv/videos/757306194
- [Discord + Twitch] Double Platform ... https://www.twitch.tv/videos/764093623
- Backend Web Programming in Haskell https://www.twitch.tv/videos/743607386
** Courses
   - https://github.com/hzlmn/haskell-must-watch
   - Functional Programming in Haskell: Professor Graham Hutton from the University of Nottingham.
     https://www.youtube.com/playlist?list=PLF1Z-APd9zK7usPMx3LGMZEHrECUGodd3
   - Haskell for imperative programmers
     https://www.youtube.com/channel/UC3xdLFFsqG701QAyGJIPT1g/videos
   - Haskell Summer Course
     https://www.youtube.com/playlist?list=PLaAHmR4OoQXcrQl7kgkraWQAgQ-8FpEmS
   - 2018 Haskell School in the Networked Imagination Laboratory
     https://www.youtube.com/playlist?list=PLyEzdf4cdMMHGqVnAzLV8eDXn6Ajj46JA
   - Haskell : Learn You a Haskell for Great Good
     https://www.youtube.com/playlist?list=PLS6urCrsYES24Fwzg5-Uga1QEbNm9kiU_
   - Haskell for Imperative Programmers
     https://www.youtube.com/playlist?list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV
   - Haskell - Functional Programming Fundamentals (Dr. Erik Meijer)
     https://www.youtube.com/playlist?list=PLoJC20gNfC2gpI7Dl6fg8uj1a-wfnWTH8
   - Programming with Categories
     http://brendanfong.com/programmingcats.html
     https://www.youtube.com/playlist?list=PLhgq-BqyZ7i7MTGhUROZy3BOICnVixETS (category theory)
** Livecoding
   - Barry (haskell book) https://www.youtube.com/channel/UCndlCtPeYygdGZ9UUKdehbw

** other
  - Zürich Friends of Haskell
    https://www.youtube.com/channel/UC2zfPMH_srjxUN5EYrfIhCw
  - Jappie Klooster
    https://www.youtube.com/channel/UCQxmXSQEYyCeBC6urMWRPVw/videos
  - HaskellRank (tsoding)
    https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx
  - lenses
    https://www.youtube.com/watch?v=cefnmjtAolY
    https://docs.google.com/file/d/0ByK3AAy5ubqady1YczU2UEYzODQ/edit
  - Jeremy Gibbons: Algorithm Design with Haskell
    https://www.youtube.com/watch?v=JJv74IJUp4E
  - NYC Haskell User's Group
    https://www.youtube.com/channel/UCzNYHE7Kj6pBqq5h8LG9Zcg
* DONE Book: Seven Languages in 7 weeks
** Haskell
- "In Haskell, indentation is significant." (?
- on Haskell, IF is a function, not a control structure, it returns a value.
- "." for function composition
  second = head . tail
- On ghci console
  > :set +t
- A partial applied function is called ~section~
- ~where~ on function definition can define local functions too
- every function does have 1(one) parameter
  - the process of reducing a function of N parameters to N of 1 param is ~currying~
#+NAME: single-line vs multi-line pattern-matching vs guards
#+begin_src haskell
fact x = if x == 0 then 1 else fact (x - 1) * x

factorial :: Integer -> Integer
factorial 0 = 1
factorial x = x * factorial (x - 1)

factorio :: Integer -> Integer
factorio x
  | x > 1     = x * factorio (x - 1)
  | otherwise = 1
#+end_src
* TODO Book: Haskell School of Music
** 1 Computer Music, Euterpea, and Haskell
*** 1.1 The Note versus Signal Dichotomy
- High/Low    level music concepts a.k.a.
  Note/Signal level music concepts
- Note: pitch and volume
- Bit depth: storage size of a single sample.
  Typically 16bits (2bytes) or 32bits (4bytes)
*** 1.2 Basic Principles of Programming
- Measures of success: correctness, efficiency, clarity
- Code often represents the author's thought process...A conventional
  musical score does not.
*** 1.3 Computation by Calculation
- In general, it is best to search first for an elegant (and correct!) solution to a problem, and later refine it for better performance.
  “Get it right first!”
- ~unfolding~ a function, is when we replace the arguments in the definition
  simple x y z = x * (y + z)
  simple 3 9 5
  > 3 * (9 + 5)
  > 42
- "simple 3 9 5 ~evaluates~ to 42"
*** 1.4 Expressions and Values
- note names are called pitch classes
- ~expressions~ entities that can be evaluated
- ~value~ are expressions that cannot be further evaluated.
  ex: 1,[1,2],(3,3),'C',"hello"
- ~diverging~ expressions are those that do not have an end
  ex: f x = f (x - 1)
  evaluate to "Bottom" value _|_
*** 1.5 Types
- Atomic or Structured
- Type Signature
  'D' :: Char
      :: reads as "has type"
   D  :: PitchClass
- Elements on a List are the same Type
- Elements on a Tuple could be different Types
*** 1.6 Function Types and Type Signatures
#+begin_src haskell
simple :: Int -> Int -> Int -> Int
simple x y z = x * (y + z)
#+end_src
- "it is a good habit to first write down the type of each function you
   are planning to define, as a first approximation to its full specification"
- f :: T1 -> T2 -- In mathematics T1 is the ~domain~ and T2 is the ~range~
- ~function application~ aka calling the funtion, has always higher precedence on application
- symbol based functions are usually called ~operators~ and are ~infix~
  - Are defined between parentheses
  - (+) :: Integer -> Integer -> Integer
- ' is a valid alphanumeric value, so f' and f'' are valid function names
*** 1.7 Abstraction, Abstraction, Abstraction
- “What are the three most important ideas in programming?" (see title)
**** 1.7.1 Naming
#+begin_src haskell
pi :: Double
pi = 3.1415
-- two definitions in one
concertA,a440 :: (PitchClass, Octave)
concertA = (A,4)
a440     = (A,4)
-- Vars
c = 42 -- is called a ~binding~
x    = let area = pi * r ** 2
       in f area + g area
#+end_src
- A4 is usually called "concert A" (because it is often used as a the note to which an orchestra
  tunes its intruments or "A440")
- {- MULTILINE COMMENT IN HASKELL -}
**** 1.7.2 Functional Abstraction
#+begin_src haskell
x = let areaF r = pi * r ** 2
    in f (areaF r1) + g (areaF r2)
note :: Dur -> Pitch -> Music Pitch
rest :: Dur -> Music Pitch
(:+:) Music Pitch -> Music Pitch -> Music Pitch -- Sequentially
(:=:) Music Pitch -> Music Pitch -> Music Pitch -- Simultanious
trans :: Int -> Pitch -> Pitch
-- Harmonizing each pN note with a third
qn = 1/4
mel = (note qn p1 :=: note qn (trans (-3) p1)) :+:
      (note qn p2 :=: note qn (trans (-3) p2)) :+:
      (note qn p3 :=: note qn (trans (-3) p3))
-- In a function
hNote :: Dur -> Pitch -> Music Pitch
hNote d p = note d p :=: note d (trans (-3) p)
-- applied
mel :: Music Pitch
mel = hNote qn p1 :+: hNote qn p2 :+: hNote qn p3
#+end_src
**** 1.7.3 Data Abstraction
- The order of ~associativity~ can be defined, either left, right or none.
- (:) operator has right associativity
#+begin_src haskell
hList          :: Dur -> [Pitch] -> Music Pitch
hList d []     = rest 0
hList d (p:ps) = hNote d p :+: hList d ps
--
mel = hList qn [p1,p2,p3]
#+end_src
*** 1.8 Haskell Equality versus Musical Equality
- 2 different melodies can be musically equivalent while being not equal by the language
- A melody can be interpreted either by his
  ~polyphonic~: grouping notes playing at the same time
  ~contrapuntal~: grouping by each voice
*** 1.9 Code Reuse and Modularity
- being able to re-use code is called ~modularity~
*** 1.10 [Advanced] Programming with Numbers 1
- Int data type is of size word (architecture dependent, 32 or 64 bits) (use Integer instead)
- In mathemathics, ~numerical analisys~ is concerned with numerical incongrueties
- If real-number acuraccy is important, be wary of floats
#+begin_src haskell
5 ∗ (−0.123456 + 0.123457)       :: Float ⇒ 4.991889e−6
5 ∗ (−0.123456) + 5 ∗ (0.123457) :: Float ⇒ 5.00679e−6
#+end_src
** 2 Simple Music
*** 2.1 Preliminaries
#+begin_src haskell
-- Type Synonyms
type Octave = Int
type Pitch  = (PitchClass, Octave)
type Dur    = Rational
-- Algebraic data type
data PitchClass = Cff | Cf | C | Dff | Cs | Df | Css | D | Eff | Ds
                | Ef | Fff | Dss | E | Ff | Es | F | Gff | Ess | Fs
                | Gf | Fss | G | Aff | Gs | Af | Gss | A | Bff | As
                | Bf | Ass | B | Bs | Bss
qn :: Dur
qn = 1/4
#+end_src
- data NAME = CONSTRUCTORS
  data Bool = False | True
*** 2.2 Notes, Music, and Polymorphism
#+begin_src haskell
-- (Value) Constructor
data Primitive = Note Dur Pitch |
                 Rest Dur
-- Type Constructor: more generic, polymorphic
data Primitive a = Note Dur a |
                   Rest Dur
-- Note :: Dur -> a -> Primitive a
-- Rest :: Dur ->      Primitive a
--
-- Another ~type constructor~, this time also recursive (aka inductive data type)
data Music a =
    Prim (Primitive a)
  | Music a :+: Music a
  | Music a :=: Music a
  | Modify Control (Music a)
-- Prim   :: Primitive a        -> Music a
-- (:+:)  :: Music a -> Music a -> Music a
-- (:=:)  :: Music a -> Music a -> Music a
-- Modify :: Control -> Music a -> Music a
#+end_src
- ~fixity declaration~
  infixr 5 :+:,:=:
- Data constructors
  - are still functions and have a type
  - are an example of polymorphic functions ~type abstraction~
#+begin_src haskell
data Control =
    Tempo      Rational          -- scale the tempo
  | Transpose  AbsPitch          -- transposition
  | Instrument InstrumentName    -- instrument label
  | Phrase     [PhraseAttribute] -- phrase attributes
  | KeySig     PitchClass Mode   -- key signature and mode
  | Custom     String            -- custom label
data Mode = Major | Minor | Ionian | Dorian | Phrygian | Lydian
             | Mixolydian | Aeolian | Locrian
             | CustomMode String
data InstrumentName = AcousticGrandPiano | BrightAcousticPiano ...
#+end_src
*** 2.3 Convenient Auxiliary Functions

*** 2.4 Absolute Pitches
- LIST !! N
  [C,D,E] !! 1 => D
** 3 Polymorphic and high order functions
- head, tail, length (examples of simple polymorphic types)
- map
- append (++)
- fold
  foldr, foldl: only difference is from which side is applied the operator, sometimes might be more performant from one side over the other
  foldr1, foldl1: versions that error on empty lists, so no init value needed
- `` functions into operator with backquotes
- () operator into a function with parentheses
- reverse, (algorithm with foldl)
- ~currying~
- currying simplification
  f x = g x
  f   = g
** 4
*** 4.2 Modules
- Module names are capitalized
  Can be hierachical
  import LIBRARY.FOLDER.MODULE
- module MODULE where
  module MODULE (EXPORT,EXPORT) where
*** 4.3 Transcribing a More Complex Score
**** 4.3.1 Auxiliary Functions
- Haskell does not permit pattern-matching against function applications.
  myFunction (Prim (Note d p)) = -- OK
  myFunction (note d p)        = -- FAIL
- times :: Int -> Music a -> Music a -- repeats
  addDur
  graceNote
- The only special cases that will not be handled using auxiliary functions are:
  1) the single staccato on note four of bar fifteen
  2) the single portamento on note three of bar sixteen.
  These situations will be addressed differently in a later chapter.
*** 4.4 Simple Algorithmic Composition

* TODO Book: Real World Haskell
- Updated code version https://github.com/tssm/up-to-date-real-world-haskell/
- Real World Haskell outdated parts https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
- Online http://book.realworldhaskell.org/read/
** 6 Using Typeclasses
*** Defining
- Different implementation depending on the type of data given.
- Defining a new ~Typeclass~ named "BasicEq3".
  We can provide *default implementations* for Typeclasses, and make one depend on the other.
#+begin_src haskell
class BasicEq3 a where
  isEqual3 :: a -> a -> Bool
  isEqual3 x y = not (isNotEqual3 x y)

  isNotEqual3 :: a -> a -> Bool
  isNotEqual3 x y = not (isEqual3 x y)
#+end_src
- An ~Instance Type~ of this typeclass, is any type that implements the functions defined in it.
- isEqual :: BasicEq a => a -> a -> Bool
  Reads:
  "For all types of *a*,
   so long as *a* is an instance of BasicEq,
   isEqual takes two parameters of type *a* and returns Bool""
*** Type Instancing
#+begin_src haskell
instance BasicEq3 Color where
  isEqual3 Red   Red   = True
  isEqual3 Green Green = True
  isEqual3 Blue  Blue  = True
  isEqual3 _     _     = False
#+end_src
*** Build-in
- Show, and the function show which returns a string from something showable
  show :: (Show a) => a -> String
  (you can derive it or explicitly Type Instance it)
  - To define your own show redefine ~show~
- Read, and the function read which takes a string and returns something readable
  read :: (Read a) => String -> a
  e.g. (read readVar)::Double
  - To define your own parser redefine ~readsPrec~
** 7
- ~Type classes~ provide ad-hoc polymorphism
  - Can define default "implementations" for the class
- ~Types~ are made instances of a particular type class
- Typeclasses
  - Show: Used to display your custom types. ghci repl uses it.
    #+begin_src haskell
data Color = Red | Green | Blue

instance Show Color where
  show Red = "rojo"
  show Green = "verde"
  show Blue = "azul"
    #+end_src

* TODO Book: The Haskell School of Expressive Language
** 3 Simple Graphics
*** 3.1 Basic Input/Output
- ~Standard Prelude~ and ~Standard Libraries~
- () is called ~unit type~, ans has only () as value
- IO
  There is a special kind of ~value~ called ~action~.
  It won't try to display it but it will take action.
  Ex: writing to a file or reading from keyboard.
  ~expressions~ or functions that evaluate to an action are called ~commands~
- IO () is often called a ~noop~, it is an action that returns ()
- putStr, putChar, writeFile, readFile, do, getLine
- ??? you can put actions on a list, but won't "do" anything unless on a do or a main ???
- sequence applied to IO has this signature
  sequence :: [IO a] -> IO ()

*** 3.2 Graphics Windows
- sierpinsky
#+begin_src haskell
fillTri :: Window -> Int -> Int -> Int -> IO ()
fillTri w x y size =
  drawInWindow w
  $ withColor Green
  $ polygon [(x,y), (x + size, y), (x, y - size), (x,y)]

minSize :: Int
minSize = 8

sierpinskiTri :: Window -> Int -> Int -> Int -> IO ()
sierpinskiTri w x y size
  | size <= minSize = fillTri w x y size
  | otherwise       = let size2 = size `div` 2
                      in do sierpinskiTri w x y size2
                            sierpinskiTri w x (y - size2) size2
                            sierpinskiTri w (x + size2) y size2
#+end_src
- david star:
  1) draw a equilateral triangle
  2) draw a new one rotated 180
  3) do 1 and 2 for each corner, but with 1/3 of a triangle size
** 4 Shapes II: Drawing shapes
- Many indirect graphics functions, to:
  1) being able to work with each shape properties
** 5 Polymorphic and High-order Funtions
* Book: Haskell Tutorial and Cookbook
** 1
#+begin_src haskell
module Main where
module Main (main) where
#+end_src
- : concatenates Char to [Char]
- !! for list index access
- ++ concatenate lists
- length of tuples will always be one (1)
|       |       |           | destructuring     |   |
|-------+-------+-----------+-------------------+---|
| tuple | (A,B) | fst/snd   | let (a,b)=('a',1) |   |
| list  | [T]   | head/tail |                   |   |

* TODO Interview: Michael Snoyman: From Haskell to Rust?
  #+DATE: Sep 13, 2020
  #+URL: https://www.youtube.com/watch?v=HKXmEFvsi6M
- Creator of Yesod/Stack
- VP at "FP Complete"
- Moved away from GHCjs
  - Purescript/Halogen
- Rust, has recently has async/await (it was "callback hell")
- Monads reinventions??: promises (js), scala (futures)
- "GO says, we don't trust the developers. Or I don't wanna bother the programmers with stuff"
  - Like overload of operators
- TALK ABOUT MONADS????
- RESUME 20:00

* TODO Videos: HaskellRank by tsoding
  playlist: https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx
** DONE HackerRank in Haskell
- interact :: (String -> String) -> IO ()
- We go from an expression that we can use on the repl to a function. By replacing ($) with (.)
- Functions: ($) (.) interact words read map sum show tail
#+begin_src haskell
main = interact $ show . sum . map read . words
main = interact $ show . sum . map read . tail . words
#+end_src
** DONE Grading Students
- (``) , guards, where, unlines
#+begin_src haskell
round5 :: Int -> Int
round5 x
    | x >= 38 && (m5 - x) < 3 = m5
    | otherwise               = x
    where m5 = x + (5 - x `mod` 5)

solve :: [Int] -> [Int]
solve xs = map round5 xs

main = interact $ unlines . map show . solve . map read . tail . words
#+end_src
** DONE Apples and Oranges
- take, drop, filter
#+begin_src haskell
let (x1:x2:xs) = [1,2,3,4,5,6,7] -- Pattern Matching
-- lambdas
map (\x -> x + 3) [0,1,2] -- => [3,4,5]
map (+ 3)         [0,1,2] -- => [3,4,5]
#+end_src
** DONE Code Warrior
- undefined :: t -- can be assigned to any type, useful to know if code just compiles
- !!
- div  :: Integral a => a -> a -> a
- even :: Integral a => a -> Bool
- odd  :: Integral a => a -> Bool
** DONE Between Two Sets
- foldl1, gcd, lcm, takeWhile
- [1 .. 4]
  [1 ..]
- Imperatively writing in Haskell
#+begin_src haskell
solve :: [Int] -> [Int] -> Int
solve = undefined

readIntList :: IO [Int]
readIntList = do line <- getLine
                 return $ map read $ words line
main = do [n, m] <- readIntList
          as     <- readIntList
          bs     <- readIntList
          putStrLn $ show $ solve as bs
#+end_src

** DONE Fold
- "Neutral element" on fold
#+begin_src haskell
Import Prelude hiding (foldl) -- Hide!!!

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f base []     = base
foldl f base (x:xs) = foldl f (f base x) xs

foldl1 :: (a -> a -> a) -> [a] -> a
foldl1 f []     = error "basaodka"
foldl1 f (x:xs) = foldl f x xs
#+end_src
** DONE Playing Basketball with Kangaroo
- maximum, minimum, inits, group
#+begin_src haskell
import Data.List
inits :: [a] -> [[a]]

λ> inits [1 .. 5]
[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]

λ> map maximum $ tail $ inits [10,5, 20, 4 ,5,2,25,1]
[10,10,20,20,20,20,25,25]

λ> group $ map maximum $ tail $ inits [10,5, 20, 4 ,5,2,25,1]
[[10,10],[20,20,20,20],[25,25]]
#+end_src
** DONE Purely Functional Solutions to Imperative Problems
*** 1
- zip
- List comprehension
#+begin_src haskell
[i     | i <- [1 .. 10]] -- [1,2,3,4,5,6,7,8,9,10]
[(i,j) | i <- [1 .. 10], j <- [1 .. 10]] -- cartesian product [(1,1),(1,2),(1,3)...]
[(i,j) | i <- [1 .. 10], j <- [1 .. 10], i /= 1] -- filter
---
-- Uses undefined as elements of an array, can also use ()
solve :: [Int] -> Int
solve (k:xs) =
  length [ undefined | (i, xi) <- zip [0 ..] xs,
                       (j, xj) <- zip [0 ..] xs,
                       i < j,
                       (xi + xj) `mod` k == 0]
#+end_src
*** 2
- group, sort, sortBy, on, compare, reverse, flip
- Ordening is the type that has 3 constructors: LT, EQ, GT
- You can compare numbers, or lists. But for special orders.
  compare :: Ord a => a -> a -> Ordering
  map compare [1,3,4]
- on basically adapts the first func with the second
  on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
#+begin_src haskell
-- :m + Data.List
import Data.List     -- For sort
import Data.Function -- For on
sortBy (\x y -> compare (length x) (length y)) [[1,2,3,4],[2,2],[0,0,0,0,0,0,0]]
sortBy (compare `on` length)                   [[1,2,3,4],[2,2],[0,0,0,0,0,0,0]]
-- => [[2,2],[1,2,3,4],[0,0,0,0,0,0,0]]
sortBy (compare `on` length) $ group $ sort [1,4,4,4,5,5,5,3]
reverse $ sortBy (compare `on` length) $ group $ sort [1,4,4,4,5,5,5,3]
sortBy (flip compare `on` length) $ group $ sort [1,4,4,4,5,5,5,3]
-- => [[1],[3],[4,4,4],[5,5,5]]
#+end_src
** DONE Solving Russian Calendar Problems in Haskell
- sum, printf (alternative to ++)
- ~eta conversion~ of \x -> abs being equal to abs
#+begin_src haskell
import Text.Printf

leapDay :: Int -> String
leapDay = printf "12.09.%d"

normDay :: Int -> String
normDay = printf "13.09.%d"
#+end_src
** DONE The Usefulness of Maybe monad
- splitAt, maybe, replicateM, read
- a type called ~Maybe~ (Just, Nothing)
  a function ~maybe~ to unwrap it
- replicateM to perform a task Nth times and return in an array
#+begin_src haskell
import Control.Monad -- for replicateM

excludeNth :: Int -> [a] -> [a]
excludeNth n xs = left ++ tail right
    where (left, right) = splitAt n xs
-- excludeNth 5 [1..10]
-- => [1,2,3,4,5,7,8,9,10]

getList :: Read a -> IO [a] -- read any type of input
getList = do
  line <- getLine
  return $ map read $ words line
-- getList :: IO [Int]
-- 1 2 3 4
-- => [1,2,3,4]

solve :: Int -> [Int] -> Int -> Maybe Int
solve k bill b
    | b > actualPrice = Just (b - actualPrice)
    | otherwise = Nothing
    where actualPrice = (sum $ excludeNth k bill) `div` 2

main :: IO ()
main = do
  [[_, k], bill, [b]] <- replicateM 3 getList
  putStrLn $ maybe "Bon appetit" show $ solve k bill b
#+end_src
** DONE Tracking Hikes with Haskell
*** Hiking
- scanl, groupBy (Data.List), filter, all
- scanl (+) 0 [1 .. 4]
  => [0,1,3,6,10,15]
- groupBy (\x y -> x /= 0 && y /= 0) [0,1,2,3,4]
  groupBy, will iterate over the list by 2 elements at the time
           when the function returns false, it separates that group
- filter (all (< 0))
*** Drawing Book
- interact $ show . resolve . map read . words
** DONE Treating Lists as Monads
- fromMaybe, sortBy, listToMaybe, liftM2
- fromMaybe - Takes a default and a maybe
  fromMaybe 5 Nothing  => 5
  fromMaybe 5 $ Just 6 => 6
- sortBy (Data.List)
- listToMaybe (Data.Maybe) -- returns Nothing or Just of the head
- liftM2 (Control.Monad)
  let keyboards = [3,1]
  let drives = [5,2,8]
  liftM2 (,) keyboards drives
- ^ generates the same than list comprehension
  AKA the ~cartesian product~
- Changing to (+) instead adds then directly
  liftM2 (+) keyboards drives
- map read . words <$> getLine -- Threat the result of getLine as a functor
** Solving Magic Square using Functional Programming
#+begin_src haskell
type Square = [[Int]]
magic :: Square
magic = [[8,1,6],
         [3,5,7],
         [4,9,2]]

rot90 :: Square -> Square
rot90 = map reverse

pp :: Square -> IO ()
pp = putStrLn . unlines . map (unwords . map show)

#+end_src
** Brute-forcing all Magic Squares
** CodeWars Strikes Again

* TODO Videos: Haskell 10X - Google TechTalks
  repo: https://github.com/google/haskell-trainings
** DONE Haskell 101 https://www.youtube.com/watch?v=cTN1Qar4HSw
- EXTRA: https://ucsd-progsys.github.io/liquidhaskell-blog/
- Everything is a function
- Everything is immutable
  Everything is *const* (on C++ on a function means that it will not change the state of the object)
- Everything is an expression, no statements
- No side effects, unless explicit
- There is NO function that can go from impure to pure code
  f :: IO a -> a
- Going from pure to impure is ok
  f :: a -> IO a
*** Lazyness (18:00)
- Reductions steps:
  - Strict evaluation: inner to outer
    Lazy evaluation: outer to inner (when needed you eval the arguments)
(-) Memory pitfalls
(-) IO and parallelism pitfalls: threads will just create the expressions, not evaluate them (use escape hatches)
(+) Huge optimizations:
  + compiler can re-arrange the code, simplify noop operations,
  + partially thanks to knowing about pure/impurity of a function
  + because only a part of the result of the operation might be needed
(+) Great expressivity (e.g. infinite structures)
*** Syntax (40:00)
- Is NOT recommended to create your own operators.
- ($) lowest priority
- (.) composition
*** Types (49:00)
- ~type~, a weak typedef, sinonyms
  type Point = (Int, Int)
  type Map k v = [(k, v)] -- ~type parameters~
- ~data structures~
  - NO methods
  - NO modifiers (setters)
  - NO private members/slots
  - YES Constructors (which are just functions)
- Data Types
#+begin_src haskell
data None    = None             -- data with 1 option, have same the constructor and type name
data Minutes = Minutes Int      -- Minutes 10
data Bool    = False   | True
data Maybe a = Nothing | Just a -- Just 10 -- Generic Type (a type argument)
data List  a =     Nil | Cell a (List a)
-- Records
data User = User String Int
-- Records, can also have named "fields". Fields are in the same namespace.
data User = User {
    userName :: String, -- Creates getters-like functions too
    userAge  :: Int
}
#+end_src
*** Functions (01:03:00)
- Operators can be constructors
- Operators pattern matching CAN short-circuit
  #+begin_src haskell
(&&) :: Bool -> Bool -> Bool
True && True = True -- does NOT short-circuit (comment this line)
True && y    = y    -- does short-circuit
_    && _    = False
  #+end_src
- Deconstructor, pattern matching
  #+begin_src haskell
data Minutes = Minutes Int

add :: Minutes -> Minutes -> Minutes
add (Minutes x) (Minutes y) = Minutes $ x + y
  #+end_src
- "backslash because it kind of looks like a lambda"
- in a function
  - you cannot use something like (==) without defining Eq on the definition
- head, is considered "bad design", as in some of the inputs panics
  also callled "partial functions"
- You can use pattern matching and guards at the same time
- Point free style: is when we define functions without defining the arguments.
                    Because it doesn't use the (.) operator.
** TODO Haskell 102 https://www.youtube.com/watch?v=Ug9yJnOYR4U
- If a library has 2 versions of a function, with (') is called "f prime".
  The one with the (') is ~eager~
  The one without the (') ~lazy~
- Problems to solve:
  1) Extend data types, ex: to show or compare
  2) Type Constrains, are sometimes mandatory to declare some functions
  3) Cascading Maybe's, might be solved with nested case's
  4) IO
     Can't apply regular functions
     Can't pattern match
     Can't get values out of it, but can operate while keeping it on IO
*** Solution
- 1 & 2 ) Declaring the type and implementing it, are separate things
  #+begin_src haskell
  -- 1)
  class Show a where
    show :: a -> String

  data Color = Red | Green | Blue

  instance Show Color where
    show Red = "Red"
    show Green = "Green"
    show Blue
  -- 2)
  -- Constraints on functions
  show :: Show a => a -> String -- a is an instance of show
  sum  :: Num  a => [a] -> a
  (==) :: Eq   a => a -> a -> Bool
  -- Constraint on instances
  instance Show a => Show (Maybe a) where
    show Nothing  = "Nothing"
    show (Just x) = "Just " ++ show x
  -- Classes can have DEFAULT implementations
  class Eq a where (==) :: a -> a -> Bool
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    a == b = not $ a /= b
    a /= b = not $ a == b
  -- Classes can also have constraints, minimun implementation is either compare or <=
  class Eq a => Ord a where
    compare :: a -> a -> Ordering
    (<=)    :: a -> a -> Bool
    (>=)    :: a -> a -> Bool
    (<)     :: a -> a -> Bool
    (>)     :: a -> a -> Bool
    max     :: a -> a -> a
    min     :: a -> a -> a
  -- Bounded, things on a class definition, can also be "values" in the class
  class Bounded a where
    minBound :: a
    maxBound :: a
  #+end_src,
- 3)
  Functions to deal with values in a context "C", or "<>" as context
  | Functor     | <$> | fmap | :: | (a -> b)   | -> | C a | -> | C b |
  | Applicative | <*> | ap   | :: | C (a -> b) | -> | C a | -> | C b |
  | Monad       | >>= | bind | :: | (a -> C b) | -> | C a | -> | C b |
- 4)
  We use *do* syntax on IO monad, as we could do with anything else that implemented
  do guarantees sequencial execution, ap can parallelize
  #+begin_src haskell
  class Applicative m => Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b
  #+end_src
*** CodeLab (01:00:00)
fmapValue
apValue
bindValue
* DONE Video: What is a Monad? - Computerphile
  https://www.youtube.com/watch?v=t1e8gqXLbsU
  - Maybe, >>=, do, return
  - A way to handle failure and """unwrap""" a series of Maybe operations
  - "A monad is some kind of type constructor like Maybe or ... together with 2 functions (return, >>=)"
  - Works with other "effects"
* DONE Course: Functional Programming in Haskell: Supercharge Your Coding
Source: https://github.com/wimvanderbauwhede/HaskellMOOC
** 1 Haskell First Steps
- Pure functional programming languages do NOT have any statements,
  no assigments, no jumps
- All is performed using expressions
- List of Operators Precedence
  https://www.haskell.org/onlinereport/exps.html
- Function applications bind thightly than anything else
- Try Haskell Online
  https://www.haskellmooc.co.uk
- :quit
  to exit ghci
- Anything with a *=* is an equation
- Generics/Templates
  #+begin_src haskell
  set :: Data.Map.Map String Integer
  set = Data.Map.empty
  set' = Data.Map.insert "Answer" 42 set
  #+end_src
- Computation is done not through *statements*
  - But through "Redex", aka reducible expression
  - If >1 redex, they can run in different orders, in parallel
    *"Church-Rosser Theorem"*
- List comprehensions
  - are transformed by the compiler into an expression
  - inspired in mathematical notation of *set comprehension*
- List:
  - (++) appending
  - (!!) indexing, negative or too big returns *undefined* (exception?)
  - (:)
  - head,tail - return *undefined* on empty list
  - Are Lazy
  - Lazyness makes it so you won't error until you access the element
  - Lazyness makes it so you can reference things that are not yet defined
  - ['a' .. 'z']
- Robust programming:
  - Well defined, or
  - All exceptions caught and handled
- A function can only return 1 value
** 2 Haskell Building Blocks
- Relation Operators:
  (==) (/=) elem (>)
- Work with lists
- zip, zip3, zipWith
- folds of (&&) and (||) are (and) and (or), which work with list of values
- IO
  - getLine/putStrLn
  - read/show
  - do blocks sequences IO actions
  - print = putStrLn + show
  - Sequencing is vital for IO actions
  - A sequence of IO actions is described as being in the ~IO Monad~
- ghci
  - :set +m, set multiline support on ghci
** 3 Data Structures and Types
- filter
   #+begin_src haskell
filter :: (a -> Bool) -> [a] -> [a]
filter pred [] = []
filter pred (x:xs)
  | pred x = x : filter pred xs
  | otherwise = filter pred xs
   #+end_src
- compositions: (f . g), first g, then f
- Point Free Notation:
  #+begin_src haskell
sum xs = foldr (+) 0 xs
sum    = foldr (+) 0     -- Point free
  #+end_src
- Different ways to define a recursive function
  1) one for each case
  2) if/then/else
  3) guards
  4) where
- fold
  #+begin_src haskell
-- foldr, elem f acc
foldr (/)  1 [2,4,8]
-- -> 8/1 4/8 0.5/2 4

-- foldl, acc  f elem
foldl (/) 16 [8,4,2,1]
-- -> 16/8 2/4 0.5/2 0.25/1
  #+end_src
- Custom data types
  - Sum Datatype: A type with different values
    data SimpleNum = One | Two | Many deriving Show
  - Product DataType (records)
    data CricketScore = Score [Char] Int Int deriving show
- https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103593
  - Convert a Tree to a list
  - Insert a value into a tree ordered
  - Sum values in a tree
- TypeClasses
  1) constrains member types (instances) to conform to an API
  2) like interfaces in C# and Java
  3) types are concrete implementations of the interface
  4) enable operator overloading
- (+) :: Num a => a -> a -> a
  Type Class Membership: a of Num
  Type Variable: a
  Context of the type: Num a
  Typeclasses: Num, Eq, Ord, Show, Read
- Interview Simon Peyton
  - Lazyness: John Huges "Why Functional Programming Matters"
    FP allows to compose things together.
    Separating the tree creation (a lazy operation) from the tree walking.
    On a eager programming language both will be tied together.
    "A modularity mechanism."
** 4 When Programs Get Bigger
- Like python, whitespace is important in Haskell, in *let* expressions anyway
- *where/let* differences
  #+begin_src haskell
  let x = numeral ++ " minister"  where numeral = "prime" in x
  let x = numeral ++ " minister"
        where numeral = "prime"
  in x
  #+end_src
  1) let, is an expression, and can be used anywhere an expression is allowed
  2) where, is NOT an expression, can only be used to provide local variables to a top level equation
     otherwise, is the catch-all of where
- *case X of*, selects based on the form of the X value
  _ is the catch-all
- *if*, expressions are syntactic sugar that gets converted into case (?
- Maybe, like Option
  Nothing, like None
  Just, like Some
- *fmap*, allows a function to be called on something inside a Maybe
*** Parsing text using high-order functions
  https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103599
  https://wiki.haskell.org/Parsec
  - Approaches to parsing
    |                   | reusability | for type of input |
    |-------------------+-------------+-------------------|
    | impose a format   |             | no                |
    | hand              | no          | no                |
    | regex             | no          | very simple       |
    | parser combinator |             | medium            |
    | parser generator* |             | heavy             |
    |-------------------+-------------+-------------------|
    * yacc/bison/antlr/happy
  - Haskell used *monads* to structure computations
  - A computation done in *monad* returns a monadic type
    In ~IO String~, we say that, "String returns inside the monad"
  - Anatomy of a basic parser:
    - All Parser Combinators are functions that return functions
    - The returned functions operates on a string
    - Take no argument or 1 string for parametrization
  - Anatomy of a parser combinator: <|>, parens
    - take other parsers as input
    - <|> is for try if any of the parser work
    - use <|> with try to do not consume on failed
  - >> can be used to shorted the *do* notation
  - builExpressionParser, Parsec helper for expression parsing
  - <?>, helper to define a custom error message
*** QuickCheck
- Property checking
- "Testing can only show the presence of bugs, not his absense"
  Edsger Dijkstra
#+begin_src shell
> import Test.QuickCheck
> -- Or verboseCheck
> quickCheck ((\n -> (\s -> ((decipher n (cipher n s)) == s)))
            :: Int -> [Char] -> Bool)
*** Failed! Falsifiable (after 6 tests and 4 shrinks):
1
"z"
#+end_src
** 5 Hardcore Haskell
- Interview
  Video: 2013 Codemania 2013: Katie Miller on Monads
  https://www.youtube.com/watch?v=MlZCiiKGbb0
  http://monads.codemiller.com/#/
- Use Cases
  Facebook: https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
  Galois: https://www.scribd.com/document/45049621/Building-a-business-with-Haskell-Case-Studies-Cryptol-HaLVM-and-Copilot
  NYT: https://www.infoq.com/presentations/haskell-newsroom-nyt/
  http://cufp.org/2014/maxime-ransan-adopting-functional-programming-with-ocaml-at-bloomberg-lp.html
- IO ()
  used to say that a function returns "no value", but causes an effect
- Type inference, starts from "a -> b -> c", then adds constraints to figure out the type
  http://dev.stephendiehl.com/fun/006_hindley_milner.html
  https://en.wikipedia.org/wiki/Unification_(computer_science)#Application:_type_inference
*** Lazyness
- Parameters of functions are not evaluated until are used in the body of the function
  - They are not evaluated if not used
  - Also applies if for example, we need a length of a list, but not the content of the list
- Infinite Data Structures
  > let ones = 1 : ones
  > repeat '1'
  > [1..]
- Example: Fibonnaci
  > let fibs = 1:1:(zipWith (+) fibs (tail fibs))
- Example: Prime numbers
  #+begin_src haskell
properfactors x = filter (\y -> (x `mod` y == 0)) [2..(x-1)]
numproperfactors x = length (properfactors x)
primes = filter (\x -> (numproperfactors)) [2..]
  #+end_src
*** Types
- Anonymouse expressions: without them haskell it would look like assembly
  (-b) + sqrt (b^2 - 4*a*c)
- Monomorphic and Polymorphic functions
- Currying
  - We can restrict functions to have just one argument and not lose expresiveness against functions that take any number of args
- Typeclasses
  - Example: the typeclass Num, is a set of types for which (+) is defined
  - Ad-Hoc vs Parametric Polymorphism
** 6 Think Like A Functional Programmer
*** Typeclasses
  https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103626
  1) Definying the data types
     #+begin_src haskell
 data Bright = Blue | Red deriving (Read,Show)
 data Pastel = Turquoise | Tan deriving (Read,Show)
     #+end_src
  2) Definying a new typeclass, for any type color there are 2 functions (dark, lighten)
     #+begin_src haskell
 class Color a where
   dark :: a -> Bool
   lighten :: a -> a
     #+end_src
  3) Instancing
     #+begin_src haskell
 instance Color Bright where
   dark = darkBright
   lighten = lightenBright

 instance Color Pastel where
   dark = darkPasterl
   lighten = lightenPaster
     #+end_src
- Predefined Typeclasses https://www.haskell.org/onlinereport/basic.html
- Implementing Show
  #+begin_src haskell
data Foo = Bar | Baz

instance Show Foo where
  show Bar = "this is bar"
  show Baz = "this is baz"
  #+end_src
*** Lambda
- Code -> System F -> Machine Language
- Conversions:
  1) Alpha
  2) Betha
  3) Eta Conversion:
     - f is equivalent to (\x -> f x)
     - (*3) is equivalent to (\x -> (*3) x)
     - Also to "factor out" trailing common arguments
*** TODO There are only functions
https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103634
- Variables and *let* expressions are just syntactic sugar for lambda expressions
- Tuples are syntactic sugar for function application
  tp = (1,2)
  tp = mkTup 1 2
- ...
*** Monads
- "Monads allow sequencing of function calls via the type system"
  aka allow computation to be chained together
  aka a computation patter
- do, can work with monads IO and Maybe, propagating Maybe errors
- Introduction to Monad Theory https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103629
  - Describe steps, are abstract, structure program, safely implement actions
  - Building Blocks
    1) Type Construct, for a type of a computation result
    2) A Function, from value to computation that will return the result
    3) A Function (>>=), from 2 computations and produces the result of applying each in sequence
**** Monad Typeclass
    #+begin_src haskell
class Monad m where
  return ::   a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b -> m b
  fail   :: String -> m a
    #+end_src
  - (>>=) "Bind"s the value of the prev computation (>>) "Then" does not
  - *fails is usually not used directly, pretend is not there*
  - 3 Monadic Laws
    | Law         |                 | = |                         |
    | right unit  | m >>= return    |   | m                       |
    | left unit   | return x >>= f  |   | f x                     |
    | associative | (m >>= f) >>= g |   | m >>= (\x -> f x >>= g) |
  - do rules
    #+begin_src haskell
    do { x }  -- >  x
    do {x ; <xs> }  -- >  x >> do { <xs> }
    do { a <- x ; <xs> }  -- >  x >>= \a -> do { <xs> }
    do { let <declarations> ; xs } -- >
    let <declarations> in do { xs }
    #+end_src
**** Maybe Monad
#+begin_src haskell
-- 1)
data Maybe a = Just a | Nothing
instance Monad Maybe where
  return         = Just    -- 2)?
  Nothing  >>= f = Nothing
  (Just x) >>= f = f x     -- 3)?
  fail _         = Nothing
#+end_src
- MonadPlus
#+begin_src haskell
instance MonadPlus Maybe where
  mzero             = Nothing
  Nothing `mplus` x = x
  m `mplus` _       = x
#+end_src
- ghci > 7.10 needs more https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/7.10
**** Other monad tutorials
- https://www.lambdacat.com/the-midnight-monad-a-journey-to-enlightenment/
- https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
- https://en.wikibooks.org/wiki/Haskell/Understanding_monads
- http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
- https://web.archive.org/web/20081206204420/http://www.loria.fr/~kow/monads/index.html
- https://blog.plover.com/prog/burritos.html
  https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
  https://chrisdone.com/posts/monads-are-burritos/
* Videos: 2013 - Simon Peyton - Adventure with Types in Haskell
  - Simon Peyton Jones Compiling without continuations
    https://www.youtube.com/watch?v=qx5NZmrFnvs
  - https://www.cs.uoregon.edu/research/summerschool/summer13/lectures/FC_in_GHC_July13.pdf
  - https://www.cs.uoregon.edu/research/summerschool/summer13/lectures/Kinds_and_GADTs.pdf
  - https://www.cs.uoregon.edu/research/summerschool/summer13/lectures/Type_inference.pdf
  - https://www.cs.uoregon.edu/research/summerschool/summer13/lectures/FunWithTypeFuns.pdf
** 1 https://www.youtube.com/watch?v=6COvD8oynmI
  slides https://www.cs.uoregon.edu/research/summerschool/summer13/lectures/ClassesJimOPLSS.pdf
- 18:40 When we declare a function with a type class (constraint?)
  the compiler "adds an extra argument" to the function, the arg is kind of like a "vtable/read-table"
- A *class* declaration turns into a *data* declaration
- Constants are also overloaded, "1" is "(fromInteger d 1)"
* Course: Packt - Learning Haskell Programming
- stack new words
  stack ghci
  stack build
  stack exec words-exe
  stack test
  stack ghc -- -dynamic test.hs
- Testing
  #+begin_src haskell
import Test.Hspec
main :: IO ()
main = hspec $ do
  describe "how to write a test" $ do
    it "should be able to run tests" $ do
      someFunc `Shouldbe` "someFunc"
  #+end_src
- ~/.stack/config.yml
- words.cabal
  - ghc-options
  - executable name
  - build-depends
- Functions that take 2 arguments, of the same type, can be used as operators with ``
- Function definition, Point-free style
  #+begin_src haskell
add a b = a + b
add a b = (+) a b
add a   = (+) a
add     = (+)
#+end_src
- List monad
  #+begin_src haskell
import Control.Monad (guard)
mapped = do
  i <- [0..9]
  return (i * 2)
filtered = do
  i <- [0..]
  guard (div2 i)
coords2 = do
  row <- [0..7]
  return $ do
    col <- [0..7]
    return (row,col)
#+end_src
- List comprehension
  #+begin_src haskell
coords3 = [ [ (row,col)| col <- [0..7] ] | row <- [0..7] ]
#+end_src
- zipWith
  #+begin_src haskell
cols = repeat [0..]
rows = map repeat [0..]
repeat8 = take 8 . repeat
cols8 = repeat8 [0..7]
rows8 = map repeat8 [0..7]
coords4 = zipWith zip rows8 cols8
      #+end_src
- (map . map)
- (zipWith . zipWith)
* TODO Course: 2016 - Haskell by Bartosz Milewski
  playlist: https://www.youtube.com/playlist?list=PL0pwx9zqJ9IamHxRXTf34dC3JeQ2oYmfJ
** DONE 1-1 => Why Haskell? https://www.youtube.com/watch?v=N6sOMGYsvFA
- "Web programming is horrible-cheap imitation of programming"
- Course based on "Parallel and concurrent programming" Oreilly book
- Based on math, Lambda Calculus
- Lists are the core DS while in other langs would be an array
- There are different "languages"/syntax in haskell
  - do
  - functions
  - types
  - constructs
- Pure Functions
  1) Equational Reasoning: Let us reason about programs, *you can inline them*
  2) Concurrent Programming: Reproducible
** DONE 1-2 => Functions https://www.youtube.com/watch?v=ybba5tcOeEY
- usually *show* produces a string that can be parsec back by *read*
- haskell keeps the more reocurring thing simple
  - in morse code (? the letter "e" is just a dot
- ~function application~ has the strongest binding
  7 - f x y z - 1
- there are no variables in haskell, they are *nonary* functions
- #+NAME: main.hs
  #+begin_src haskell
--sqDist :: Num a => a -> a -> a
sqDist :: Double -> Double -> Double
sqDist x y = x^2 + y^2

main = print (sqDist 3 4)
#+end_src
- load file
  #+begin_src haskell
> :l main.hs
> main
25
> :t sqDist
sqDist :: Num a => a -> a -> a -- the "type language"
#+end_src
- there are things that are NOT expressable in haskell,
  that are left to the user (ex: axioms)
- main :: IO ()
  print :: Show a => a -> IO ()
  putStrLn :: String -> IO ()
- ghci commands
  #+begin_src
  :l FILENAME
  :r reload
  :t expand type
  :i info
  :q quit
  #+end_src
- Num is a ~typeclass~, a class of types, Double is type
- IO is a type constructor
- () is a type constructor for unit type
** DONE 2-1 => More Functions
- code
  #+begin_src haskell
sq x = x * x -- replacing parens
sqDist (x,y) = x^2 + y ^2
main = print $ sqDist (3,4)
-- sq - 1 -- means substract 1 from sq

main = print $ sq $ 2 + 3
main = print $ sq (2 + 3)
main = print $ sq 2+3 -- NOT the same

dist pt = sqrt $ sqDist pt -- Partial Application in Function composition
dist = sqrt . sqDist -- Point free notation + composition
  #+end_src
- on tuples: fst, snd
- There are 10 levels of precedence, space has 10
  - lowest possible binding is $
  - spaces kind of does't matter at times, precedence does
- (.) ~function composition~
  - very high precedence
  - sq . sqDist -- reads "sq after sqDist"
  - the opposite direction than "|>" in fsharp
- the definition of a function is with a -> b -> c because
  - ~partial application~ happens automatically
  - using a tuple as an argument, is not convenient for partial application
- polymorphic functions:
  1) parametric: same behaviour for all types
     "it can handle values uniformly without depending on their type. 
      Parametric polymorphism is a way to make a language more expressive
      while still maintaining full static type-safety."
      ex: map function
  2) adhoc: different behaviour, for different types of arguments
** DONE 2-2 => Product data types https://www.youtube.com/watch?v=a6IkhX1zgXI
- ELM isn't lazy evaluated
- partial application of an operator is called ~operator section~
  #+begin_src haskell
inc x = 1 + x
inc x = (+) 1 x  -- () changes infix to prefix operator
inc   = (+ 1)    -- "x" cancells out
#+end_src
- ~Void~
  1) is type with no elements
  2) an empty set
  3) no construct
- ~Unit~
  1) is type with one element
  2) is the "Singleton" Type denoted by "()"
  3) tuple of 0 elements
- Define a ~NEW type~ with:
  > data Unit = CONSTRUCTOR
              = U
  > data ()   = ()
    TYPE      = DATA
    CONSTRUCTOR CONSTRUCTOR
- Are different namespace for types and data constructors
- Every constructor is a function (capitalized for some reason).
- 20:00
  ~Cartesian product~ of types, since types are sets
  > data Product a b = P a b
  > :t P
  P :: a -> b -> Product a b
  - ~type constructor~ is Product, used in type declarations
  - ~data constructor~ is P, used in destructoring and constructing new type instance
- When you have >2 components, you are better using a ~record~ where fields are named
** DONE 3-1 => Laziness https://www.youtube.com/watch?v=jWrRs-l8C1U
:set -Wall
:set -fforce-recomp
:k <TYPE_CONSTRUCTOR>
:sprint value -- Prints the value without evaluating it
*** Kinds
- The Type Constructors have types and those types are called ~kinds~
- "In haskell we don't want to use many names,
  because they polute the namespace"
- ~*~ in type #kind language" means "any type"
  #+begin_src haskell
> :t (,) -- Data Constructor
(,) :: a -> b -> (a, b)
> :k (,) -- Type Constructor
(,) :: * -> * -> *
#+end_src
- "If you define a data type in Haskell you can promote it to a kind"
  Type Promotion
  https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html
*** Lazyness (12:30)
- ML, In the book "Persistent Data Structures", he had to implement special extensions to ML to make it lazy.
- Haskell by default is lazy evaluated
- Haskell has ~polymorphic values~, so we need to type ":: Int" here
  #+begin_src haskell
  > let x = 1 + 2 :: Int
  > :sprint x
   x = _
  > x
   3
  > :sprint x
   x = 3
#+end_src
- We can force eager evaluation by using ~seq~,
  it "sequences" its arguments, it evaluates the 1st BEFORE evaluating the 2nd
  #+begin_src haskell
  > let x = 2 + 3 :: Int
  > let y = x + 1
  > print (seq y ())
   ()
  > :sprint y
   y = 6
#+end_src
- ~swap~, showing how is lazy. You would need to ~seq~ both x and z to compute the result.
  #+begin_src haskell
  > import Data.Tuple
  > let z = swap (x,x+1)
  > :sprint z
   z = _
#+end_src
** DONE 3-2 => Sum types https://www.youtube.com/watch?v=MagayXbH4oY
- In product types, we had projections
  In Sum types, we have injections
- Unlike product types, on ~sum types~ we can have *either* from a or b
  - In terms of sets is like a "discriminated union", aka "tagged union"
- "|" as in OR
- Example: Either
  Unlike Product Types, where we have a native type (the tuple) in haskell we don't have a native one.
  We have one defined in the stdlib.
  ~Either~ is used to return either an error or a valid output.
  "Used as a poor man's exception", exceptions are more complicated because they might have more types, here are just strings
  #+begin_src haskell
data Either a b = Left a | Right b

safeSqrt :: Either String Double -> Either String Double
safeSqrt (Left str) = Left str
safeSqrt (Right x) = if x < 0
                     then Left "Error"
                     else Right (sqrt x)

-- Alternative using case
safeSqrt sx =
    case sx of
        Left str -> Left str
        Right x -> if x < 0
                   then Left "Error"
                   else Right (sqrt x)
#+end_src
- Example: Bool
  What in other languages would be an "enumeration type" here is just another sum
  - data Bool = True | False
- Void and Unit
  #+begin_src haskell
data X a = X a | Y Void -- a + 0 = a, you can never use Y
type Y a = (a, ())      -- a * 1 = a, equivalent or isomorphic a = (a,())
type Z a = (a, Void)    -- a * 0 = 0, you can never create this type
#+end_src
** DONE 4-1 => Recursion https://www.youtube.com/watch?v=F-nAAIH4e2s
- A power series, translates into Algebraic Data Types as
  [ () | a | (a,a) | (a,a,a) |
  where | is sum
  aka a list
- -- l(a) = l + a . l(a)
  data List a = Nil | Cons a (List a)
- ~:~ Cons operator
- ~..~ range operator for lists
  [0..]         => PRINTSUNTILSTOP
  [0..4]        => [0,1,2,3,4]
,  take 4 [0..]  => [0,1,2,3]
- the code for a recursive *len* function gets converted by the compiler into a loop
** DONE 4-2 => Functors
- ~Induction~ in mathematics, recursive proofs
  ~Structural Induction~ when there is some kind of ordering, partial or not, example in list
- A ~Functor~ is sorta like a container of a's
  - (data) Has a shape
  - Has contents, values or can be a function
  - (type constructor) It has to be polimorphic on his type
  - (map) There has to be a way to modify uniformly the content of it
- A functor is a class of types
  #+begin_src haskell
-- Functor is the "class name"
-- f is a "type constructor"
-- fmod is a generalization of functors, a method of the functor
class Functor f where
  fmod :: (a -> b) -> f a -> f b
#+end_src
- Axioms
  1) Needs to be proven on each case for the container:
     fmap id = id
  2) It follows that: "Fusion Law"
     fmap g . fmap f = fmap (g . f)
*** Example: Binary tree definition
  #+begin_src haskell
data Tree a = Empty | Node (Tree a) a (Tree a)
instance Functor Tree where -- NOT "Tree a"
  --fmap = mapT
  fmap f Empty = Empty
  fmap f (Node l v r) = Node l (f v) r
  #+end_src
*** Example: ~Maybe~ is a functor
  #+begin_src haskell
data Maybe a = Nothing | Just a
mapm f Nothing  = Nothing
mapm f (Just x) = Just (f x)
    #+end_src
*** Example: Identity Functor, is also a monad, without side-effects
  #+begin_src haskell
data I a = I a
instance Functor I where
  fmap f (I x) = I (f x)
  #+end_src
*** Example: Function container
  #+begin_src haskell
-- e for environment
-- a is the free-variable
data Reader e a = Reader (e -> a)
instance Functor (Reader e) where
  fmap g (Reader f) = Reader (g . f)
  #+end_src
** DONE 5-1 => Monads
- Monads
  - They are not impure, they do not encapsulate side effects
  - They are useful when dealing with side effects, but they don't deal with it themselves
- "Kleisli arrows", side-effects solved by it
  a -> m b
  m :: * -> *
*** Example: a functor with state and his proof
  #+begin_src haskell
data State s a = State (s -> (a,s))

instance Functor (State s) where
  fmap g (State f) = State -- f'
    (\st -> let (a,st') = f st
                b       = g a
            in  (b,st'))
  -- g  is (a -> b)
  -- f  is (s -> (a,s))
  -- f' is (s -> (b,s))
  #+end_src
*** >=> "fish operator"
- A more general composition of functions, for "Kleisi arrows"
- Needed to represent a common boilerplate with less work
- Signature
  (.)   :: (b->  c) -> (a->  b) -> (a->  c)
  (>=>) :: (a->m b) -> (b->m c) -> (a->m c)
- Example:
  (a -> [b]) -> (b -> [c]) -> (a -> [c])
    #+begin_src haskell
f >=> g = \a -> let  bs = f a
                    css = fmap g bs
                in concat css
f >=> g = concat . fmap g . f -- Note: it has to be Functor
  #+end_src
*** MONAD is
The essence of monads is >=> and composition
  - a type constructor (m)
  - a fish operator (>=>)
  - and return
*** ~return~ The equivalent of the "id" function for the (.) operator
#+begin_src haskell
return :: a -> m a
return >=> f = f

f >=> return = f
(f >=> g) >=> h = f >=> (g >=> h) -- associativity
#+end_src
** DONE 5-2 => The Monad Class (continuations)
- Tetris, is how working with types in haskell is described
- (>>=) ~bind~, "just give me the result, don't give me the whole function"
  - is "easy" to define the *Kleisi Arrow* if you have the *bind*
  - similarly is easy define fmap with return and bind
*** Monad class
   #+begin_src haskell
class Monad m where
--class Functor m => Monad m where
--class Applicative => Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a->m b) -> m b
  --(>=>)  :: (a->m b) -> (b->m c) -> (a->m c)
  --join   :: m (m a) -> m a
#+end_src
*** Example: Either, proof that it is a Monad
  "Either is a better version of Mayber"
  #+begin_src haskell
instance Monad (Either s) where
  return x = Right x
  ea >>= k = case ea of -- k is a function, name from "continuation"
               Left  s -> Left s
               Right x -> k s
  #+end_src
*** Example: >>= using bind
  #+begin_src haskell
safeRecSqrt x = safeSqrt x >>=
  (\y -> if y == 0
         then Left "div by 0"
         else return (1/y))
  #+end_src
*** Example: >>= using bind, with do (hides the safe-effect)
  #+begin_src haskell
safeRecSqrt x = do
  y <- safeSqrt x -- implicit bind
  if y == 0
  then Left "div by 0"
  else return (1/y) -- always parens after return
  #+end_src
*** Example: >>= using bind, with do, without return but a function that returns the monad
  #+begin_src haskell
safeRecSqrt x = do
  y <- safeSqrt x -- implicit bind
  safeRec y
  #+end_src
** DONE 6-1 => IO Monad
- It's a state monad
- Math has no concept of time, not concept of "block"
- In an ~Applicative~ you cannot fork between choices, like in Monads
- "Think of this as Haskell programmers producing a program for the runtime.
  The runtime is impure. But the program is pure."
- (>>) There is a special version of *bind* that does not bind a variable
  (>>) :: ma -> mb -> mb
- "In imperative programming, the monad sits on the semicolon (;)"
*** Example: Sugared IO() with *do*
  #+begin_src haskell
main :: IO()
main = do
  putStrLn "What's your name?"
  name <- getLine
  putStrLn $ "Hi " ++ name
  #+end_src
*** Example: desugared IO()
  #+begin_src haskell
main = putStrLn "What's your name?"
       >> getLine
       >>= \name -> putStrLn $ "Hi " ++ name
  #+end_src
** DONE 6-2 => Parallellism and Concurrency
- You can escape monads like Maybe, but not IO
  - You have no way of run/execute IO
  - The runtime has some way of run it
- Naming: When dealing with functions in monads arguments, are usually called run*
*** Concurrent
- is older, in practice
- you want to *structure* the program differently,
  easier to think about it
- usually non-deterministic (due the added "time" dimension of in which order the threads run)
- goal is ~latency~
  - threads might slow down your program,
    but that is ok for concurrency,
    what is important is the *reaction time*
*** Parallelism
- no way to introduce data-races
- In Haskell: "because of lazyness paralellism is right there"
  - sparks: pointers to thunks
  - thunks can be marked as sparks and place into queue to run in parallel
  - there is a queue per processor, that processor can steal from it when idle
  - queues are maintained using CAS operations
    - CAS operations cause to flush the cpu caches
    - CAS might keep retring several times until it can run
    - the cpu owner of the queue, does NOT have to use CAS to pop values
  - there is a thread-pool per cpu, to deal with FFI calls that might hang
  - is NOT a problem if 2 cpus run the same job, due function purity
- can be deterministic or not (in haskell is deterministic)
- is the way using multicore/gpu
- goals is ~throughput~ and performance
** 7-1 => The Eval monad
- Identity Monad
  #+begin_src haskell
data Identity a = Id a
runIdentity (Id x) x
instance Monad Identity where
  return   = Id
  ix >>= f = f (runIdentity ix)
  #+end_src
- Eval Monad, similar to the identity monad
  #+begin_src haskell
data Eval a = Done a
runEval (Done x) = x
instance Monad Eval where
  return         = Done
  (Done x) >>= f = f x -- "strict monad", eagear unpack, instead of run runEval
#+end_src
- Additional Eval functions:
  #+begin_src haskell
rpar :: a -> Eval a -- runs "a" expression in parallel
rseq :: a -> Eval a -- runs "a" fully before return
#+end_src
- Example: calculates f on different args, where f can take a long time
  We do the operations in the do monad, and then exit the monadic world in runEval
  #+begin_src haskell
runEval $ do
  x' <- rpar (f x)
  y' <- rpar (f y)
  return (x',y')
  #+end_src
** 7-2 => Parallel sudoku solver, strategies, overview of Haskell parallelism.
** 8-1 => Concurrent Haskell, MVars
** 8-2 => Software Transactional Memory
* Course: Bartosz Milewski - Category Theory I
  https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
  https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
** 1.1: Motivation and Philosophy
** 1.2: What is a category?
** 2.1: Functions, epimorphisms
** 2.2: Monomorphisms, simple types
** 3.1: Examples of categories, orders, monoids
** 3.2: Kleisli category
** 4.1: Terminal and initial objects
** 4.2: Products
** 5.1: Coproducts, sum types
** 5.2: Algebraic data types
** 6.1: Functors
** 6.2: Functors in programming
** 7.1: Functoriality, bifunctors
** 7.2: Monoidal Categories, Functoriality of ADTs, Profunctors
** 8.1: Function objects, exponentials
** 8.2: Type algebra, Curry-Howard-Lambek isomorphism
** 9.1: Natural transformations
** 9.2: bicategories
** 10.1: Monads
** 10.2: Monoid in the category of endofunctors
* Course: Graham Hutton - Advanced Haskell Programming
** 06 Functors
- Functor: Generalizing further the concept of *map*, we can map over things other than lists.
- class definition, we use fmap since map already exists
  #+begin_src haskell
clas Functor f where -- f is a parametrized type/type constructor
  fmap :: (a -> b) -> f a -> f b
  #+end_src
- "Whenever you see parametrized type,
   ask if you can make into an instance of Functor"
- Why?
  1) ~fmap~ We can use the same function for things that are essentially the same
  2) ~Generics~ Can define *generic* functions that work with any functorial type
     using the Functor typeclass
*** Example: declaration for lists
  #+begin_src haskell
instance Functor [] where -- [] is the type constructor
  fmap = map
  #+end_src
*** Example: declaration for Maybe
  > fmap (+1) Nothing
    Nothing
  > fmap (*2) (Just 3)
    Just 6
  #+begin_src haskell
data Maybe a = Nothing | Just a
instance Functor Maybe where
  -- fmap :: (a->b) -> Maybe a -> Maybe b
  fmap g Nothing  = Nothing
  fmap g (Just x) = Just $ g x
  #+end_src
*** Example: declaration for a tree
  > fmap length (Left "abc")
    Leaf 3
  > fmap even (Node (Leaf 1) (Leaf 2))
    Node (Leaf False) (Leaf True)
  #+begin_src haskell
data Tree a = Leaf a
            | Node (Tree a) (Tree a)
instance Functor Tree where
  -- fmap :: (a->b) -> Tree a -> Tree b
  fmap g (Leaf x)   = Leaf (g x)
  fmap g (Node l r) = Node (fmap g l) (fmap g r)
  #+end_src
** 07 Applicative Functors
- Problem: Example of naive declaration of Functor2
  #+begin_src haskell
class Functor2 f where
  fmap2 :: (a->b->c) -> f a -> f b -> f c
  #+end_src
- Applicative Functor
  #+begin_src haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a->b) -> f a -> f b -- generalized form of "applicative function"
  #+end_src
- Further generalization to *Type Constructors* with >1 arguments
  - Functions that take as many arguments as we like
- Example of fmap2
  > fmap (+) (Just 1) (Just 2)
    Just 3
- <*> star operator, read as "applied to"
- Usage, ~applicative style~
  #+begin_src haskell
pure g <*> x <*> y <*> z -- "star" separates the function arguments
((g x) y) z -- function application and star group to the left
  #+end_src
- Examples: fmap0 fmap1 declarations in applicative style
  #+begin_src haskell
fmap0 :: a -> f a
fmap0 = pure

fmap1 :: (a->b) -> f a -> f b
fmap1 g x = pure g <*> x
  #+end_src
- Example: Applicative Maybe
  > pure (+) <*> Nothing <*> Just 2
    Nothing
  #+begin_src haskell
instance Applicative Maybe where
  -- pure :: a -> Maybe a
  pure x = Just x
  -- (<*>) :: Maybe (a->b) -> Maybe a -> Maybe b
  Nothing  <*> mx = Nothing
  (Just g) <*> mx = fmap g mx
  #+end_src
- Examples: Applicative for lists
  "Applicative style for lists supports a form of Non-Deterministic
   programming where we apply pure functions to multi valued arguments"
  > pure (+1) <*> [1,2,3]
    [2,3,4]
  > pure (+) <*> [1] <*> [2]
    [3]
  > pure (*) <*> [1,2] <*> [3,4]
    [3,4,6,8]
** 08 Monads I
- "Monads is about absorving a common patter and applying it"
- "The idea of applicative functors, captures a patter of programing with effects"
  "We apply pure functions. To effectful arguments."
- Failled attempt of use *safediv* using applicatives
  #+begin_src haskell
eval :: Expr -> Maybe Int
eval (Val n) = pure n
eval (Div x y) = pure safediv <*> x <*> y -- ! does NOT compile, safediv is NOT pure
  #+end_src
- >>= "into", "in", "bind"
** 09 Monads II
- In haskell, the class of applicative functors that support the bind operator, are monads
  #+begin_src haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
  return = pure
  #+end_src
- You can use *do* notation with lists, same way you would with list comprehensions.
- ~State Transformer~ is a function which takes a state and returns a possible modified output state
  type State = ...
  type ST = State -> State
  type ST a = State -> (a, State)
- ~ST~ as a data declaration, S is dummy constructor
  data ST a = S (State -> (a,State))
  newtype ST a = S(State -> (a,State))
- ~app~ A way to apply them
  app :: ST a -> State -> (a,State)
  app (S st) s = st s
